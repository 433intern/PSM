#pragma warning(disable:4996)
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AgentProtocol.proto

#ifndef PROTOBUF_AgentProtocol_2eproto__INCLUDED
#define PROTOBUF_AgentProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace agent {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AgentProtocol_2eproto();
void protobuf_AssignDesc_AgentProtocol_2eproto();
void protobuf_ShutdownFile_AgentProtocol_2eproto();

class csAgentIDRequest;
class scAgentIDResponse;
class csProcessListRequest;
class scProcessListResponse;
class csCounterListRequest;
class scCounterListResponse;
class csAgentReady;
class CurrentProcess;
class csCurrentProcessListSend;
class scHealthCheck;
class csHealthAck;
class scProcessCommandRequest;
class csProcessCommandResponse;
class scCounterCommandRequest;
class csCounterCommandResponse;
class scStartRecord;
class scStopRecord;
class Log;
class ProcessInfos;
class csTotalProcessInfoSend;
class MachineInfos;
class csTotalMachineInfoSend;
class scProcessRestrictionRequest;
class csProcessRestrictionResponse;
class csRecordResponse;

enum csProcessCommandResponse_Result {
  csProcessCommandResponse_Result_SUCCESS = 0,
  csProcessCommandResponse_Result_FAILURE = 1
};
bool csProcessCommandResponse_Result_IsValid(int value);
const csProcessCommandResponse_Result csProcessCommandResponse_Result_Result_MIN = csProcessCommandResponse_Result_SUCCESS;
const csProcessCommandResponse_Result csProcessCommandResponse_Result_Result_MAX = csProcessCommandResponse_Result_FAILURE;
const int csProcessCommandResponse_Result_Result_ARRAYSIZE = csProcessCommandResponse_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* csProcessCommandResponse_Result_descriptor();
inline const ::std::string& csProcessCommandResponse_Result_Name(csProcessCommandResponse_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    csProcessCommandResponse_Result_descriptor(), value);
}
inline bool csProcessCommandResponse_Result_Parse(
    const ::std::string& name, csProcessCommandResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<csProcessCommandResponse_Result>(
    csProcessCommandResponse_Result_descriptor(), name, value);
}
enum csCounterCommandResponse_Result {
  csCounterCommandResponse_Result_SUCCESS = 0,
  csCounterCommandResponse_Result_FAILURE = 1
};
bool csCounterCommandResponse_Result_IsValid(int value);
const csCounterCommandResponse_Result csCounterCommandResponse_Result_Result_MIN = csCounterCommandResponse_Result_SUCCESS;
const csCounterCommandResponse_Result csCounterCommandResponse_Result_Result_MAX = csCounterCommandResponse_Result_FAILURE;
const int csCounterCommandResponse_Result_Result_ARRAYSIZE = csCounterCommandResponse_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* csCounterCommandResponse_Result_descriptor();
inline const ::std::string& csCounterCommandResponse_Result_Name(csCounterCommandResponse_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    csCounterCommandResponse_Result_descriptor(), value);
}
inline bool csCounterCommandResponse_Result_Parse(
    const ::std::string& name, csCounterCommandResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<csCounterCommandResponse_Result>(
    csCounterCommandResponse_Result_descriptor(), name, value);
}
enum csProcessRestrictionResponse_Result {
  csProcessRestrictionResponse_Result_SUCCESS = 0,
  csProcessRestrictionResponse_Result_FAILURE = 1
};
bool csProcessRestrictionResponse_Result_IsValid(int value);
const csProcessRestrictionResponse_Result csProcessRestrictionResponse_Result_Result_MIN = csProcessRestrictionResponse_Result_SUCCESS;
const csProcessRestrictionResponse_Result csProcessRestrictionResponse_Result_Result_MAX = csProcessRestrictionResponse_Result_FAILURE;
const int csProcessRestrictionResponse_Result_Result_ARRAYSIZE = csProcessRestrictionResponse_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* csProcessRestrictionResponse_Result_descriptor();
inline const ::std::string& csProcessRestrictionResponse_Result_Name(csProcessRestrictionResponse_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    csProcessRestrictionResponse_Result_descriptor(), value);
}
inline bool csProcessRestrictionResponse_Result_Parse(
    const ::std::string& name, csProcessRestrictionResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<csProcessRestrictionResponse_Result>(
    csProcessRestrictionResponse_Result_descriptor(), name, value);
}
enum csRecordResponse_Result {
  csRecordResponse_Result_START_SUCCESS = 0,
  csRecordResponse_Result_START_FAILURE = 1,
  csRecordResponse_Result_STOP_SUCCESS = 2,
  csRecordResponse_Result_STOP_FAILURE = 3
};
bool csRecordResponse_Result_IsValid(int value);
const csRecordResponse_Result csRecordResponse_Result_Result_MIN = csRecordResponse_Result_START_SUCCESS;
const csRecordResponse_Result csRecordResponse_Result_Result_MAX = csRecordResponse_Result_STOP_FAILURE;
const int csRecordResponse_Result_Result_ARRAYSIZE = csRecordResponse_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* csRecordResponse_Result_descriptor();
inline const ::std::string& csRecordResponse_Result_Name(csRecordResponse_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    csRecordResponse_Result_descriptor(), value);
}
inline bool csRecordResponse_Result_Parse(
    const ::std::string& name, csRecordResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<csRecordResponse_Result>(
    csRecordResponse_Result_descriptor(), name, value);
}
enum agentType {
  AgentIDRequest = 0,
  AgentIDResponse = 1,
  ProcessListRequest = 2,
  ProcessListResponse = 3,
  CounterListRequest = 4,
  CounterListResponse = 5,
  CurrentProcessListSend = 6,
  HealthCheck = 8,
  HealthAck = 9,
  ProcessCommandRequest = 10,
  ProcessCommandResponse = 11,
  CounterCommandRequest = 12,
  CounterCommandResponse = 13,
  ProcessRestrictionRequest = 14,
  ProcessRestrictionResponse = 15,
  StartRecord = 16,
  StopRecord = 17,
  ProcessInfoSend = 18,
  MachineInfoSend = 21,
  AgentReady = 22,
  RecordResponse = 23
};
bool agentType_IsValid(int value);
const agentType agentType_MIN = AgentIDRequest;
const agentType agentType_MAX = RecordResponse;
const int agentType_ARRAYSIZE = agentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* agentType_descriptor();
inline const ::std::string& agentType_Name(agentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    agentType_descriptor(), value);
}
inline bool agentType_Parse(
    const ::std::string& name, agentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<agentType>(
    agentType_descriptor(), name, value);
}
enum ProcessCommandType {
  START = 0,
  RESTART = 1,
  STOP = 2,
  ADDLIST = 3,
  DELETELIST = 4,
  ALLSTOP = 5
};
bool ProcessCommandType_IsValid(int value);
const ProcessCommandType ProcessCommandType_MIN = START;
const ProcessCommandType ProcessCommandType_MAX = ALLSTOP;
const int ProcessCommandType_ARRAYSIZE = ProcessCommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcessCommandType_descriptor();
inline const ::std::string& ProcessCommandType_Name(ProcessCommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcessCommandType_descriptor(), value);
}
inline bool ProcessCommandType_Parse(
    const ::std::string& name, ProcessCommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcessCommandType>(
    ProcessCommandType_descriptor(), name, value);
}
enum CounterCommandType {
  CADDLIST = 1,
  CDELETELIST = 2
};
bool CounterCommandType_IsValid(int value);
const CounterCommandType CounterCommandType_MIN = CADDLIST;
const CounterCommandType CounterCommandType_MAX = CDELETELIST;
const int CounterCommandType_ARRAYSIZE = CounterCommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CounterCommandType_descriptor();
inline const ::std::string& CounterCommandType_Name(CounterCommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CounterCommandType_descriptor(), value);
}
inline bool CounterCommandType_Parse(
    const ::std::string& name, CounterCommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CounterCommandType>(
    CounterCommandType_descriptor(), name, value);
}
enum Restriction {
  USER_TIME_LIMIT = 0,
  MAX_WORKING_SET_SIZE = 1,
  MIN_WORKING_SET_SIZE = 2
};
bool Restriction_IsValid(int value);
const Restriction Restriction_MIN = USER_TIME_LIMIT;
const Restriction Restriction_MAX = MIN_WORKING_SET_SIZE;
const int Restriction_ARRAYSIZE = Restriction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Restriction_descriptor();
inline const ::std::string& Restriction_Name(Restriction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Restriction_descriptor(), value);
}
inline bool Restriction_Parse(
    const ::std::string& name, Restriction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Restriction>(
    Restriction_descriptor(), name, value);
}
// ===================================================================

class csAgentIDRequest : public ::google::protobuf::Message {
 public:
  csAgentIDRequest();
  virtual ~csAgentIDRequest();

  csAgentIDRequest(const csAgentIDRequest& from);

  inline csAgentIDRequest& operator=(const csAgentIDRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csAgentIDRequest& default_instance();

  void Swap(csAgentIDRequest* other);

  // implements Message ----------------------------------------------

  csAgentIDRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csAgentIDRequest& from);
  void MergeFrom(const csAgentIDRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline ::google::protobuf::int32 token() const;
  inline void set_token(::google::protobuf::int32 value);

  // required int32 hostIP = 2;
  inline bool has_hostip() const;
  inline void clear_hostip();
  static const int kHostIPFieldNumber = 2;
  inline ::google::protobuf::int32 hostip() const;
  inline void set_hostip(::google::protobuf::int32 value);

  // required double ramSize = 3;
  inline bool has_ramsize() const;
  inline void clear_ramsize();
  static const int kRamSizeFieldNumber = 3;
  inline double ramsize() const;
  inline void set_ramsize(double value);

  // @@protoc_insertion_point(class_scope:agent.csAgentIDRequest)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_hostip();
  inline void clear_has_hostip();
  inline void set_has_ramsize();
  inline void clear_has_ramsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 token_;
  ::google::protobuf::int32 hostip_;
  double ramsize_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csAgentIDRequest* default_instance_;
};
// -------------------------------------------------------------------

class scAgentIDResponse : public ::google::protobuf::Message {
 public:
  scAgentIDResponse();
  virtual ~scAgentIDResponse();

  scAgentIDResponse(const scAgentIDResponse& from);

  inline scAgentIDResponse& operator=(const scAgentIDResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scAgentIDResponse& default_instance();

  void Swap(scAgentIDResponse* other);

  // implements Message ----------------------------------------------

  scAgentIDResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scAgentIDResponse& from);
  void MergeFrom(const scAgentIDResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 agentID = 1;
  inline bool has_agentid() const;
  inline void clear_agentid();
  static const int kAgentIDFieldNumber = 1;
  inline ::google::protobuf::int32 agentid() const;
  inline void set_agentid(::google::protobuf::int32 value);

  // required bool alreadyRunning = 2;
  inline bool has_alreadyrunning() const;
  inline void clear_alreadyrunning();
  static const int kAlreadyRunningFieldNumber = 2;
  inline bool alreadyrunning() const;
  inline void set_alreadyrunning(bool value);

  // @@protoc_insertion_point(class_scope:agent.scAgentIDResponse)
 private:
  inline void set_has_agentid();
  inline void clear_has_agentid();
  inline void set_has_alreadyrunning();
  inline void clear_has_alreadyrunning();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 agentid_;
  bool alreadyrunning_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static scAgentIDResponse* default_instance_;
};
// -------------------------------------------------------------------

class csProcessListRequest : public ::google::protobuf::Message {
 public:
  csProcessListRequest();
  virtual ~csProcessListRequest();

  csProcessListRequest(const csProcessListRequest& from);

  inline csProcessListRequest& operator=(const csProcessListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csProcessListRequest& default_instance();

  void Swap(csProcessListRequest* other);

  // implements Message ----------------------------------------------

  csProcessListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csProcessListRequest& from);
  void MergeFrom(const csProcessListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:agent.csProcessListRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csProcessListRequest* default_instance_;
};
// -------------------------------------------------------------------

class scProcessListResponse : public ::google::protobuf::Message {
 public:
  scProcessListResponse();
  virtual ~scProcessListResponse();

  scProcessListResponse(const scProcessListResponse& from);

  inline scProcessListResponse& operator=(const scProcessListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scProcessListResponse& default_instance();

  void Swap(scProcessListResponse* other);

  // implements Message ----------------------------------------------

  scProcessListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scProcessListResponse& from);
  void MergeFrom(const scProcessListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string processName = 1;
  inline int processname_size() const;
  inline void clear_processname();
  static const int kProcessNameFieldNumber = 1;
  inline const ::std::string& processname(int index) const;
  inline ::std::string* mutable_processname(int index);
  inline void set_processname(int index, const ::std::string& value);
  inline void set_processname(int index, const char* value);
  inline void set_processname(int index, const char* value, size_t size);
  inline ::std::string* add_processname();
  inline void add_processname(const ::std::string& value);
  inline void add_processname(const char* value);
  inline void add_processname(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& processname() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_processname();

  // @@protoc_insertion_point(class_scope:agent.scProcessListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> processname_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static scProcessListResponse* default_instance_;
};
// -------------------------------------------------------------------

class csCounterListRequest : public ::google::protobuf::Message {
 public:
  csCounterListRequest();
  virtual ~csCounterListRequest();

  csCounterListRequest(const csCounterListRequest& from);

  inline csCounterListRequest& operator=(const csCounterListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csCounterListRequest& default_instance();

  void Swap(csCounterListRequest* other);

  // implements Message ----------------------------------------------

  csCounterListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csCounterListRequest& from);
  void MergeFrom(const csCounterListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isMachine = 1;
  inline bool has_ismachine() const;
  inline void clear_ismachine();
  static const int kIsMachineFieldNumber = 1;
  inline bool ismachine() const;
  inline void set_ismachine(bool value);

  // @@protoc_insertion_point(class_scope:agent.csCounterListRequest)
 private:
  inline void set_has_ismachine();
  inline void clear_has_ismachine();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool ismachine_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csCounterListRequest* default_instance_;
};
// -------------------------------------------------------------------

class scCounterListResponse : public ::google::protobuf::Message {
 public:
  scCounterListResponse();
  virtual ~scCounterListResponse();

  scCounterListResponse(const scCounterListResponse& from);

  inline scCounterListResponse& operator=(const scCounterListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scCounterListResponse& default_instance();

  void Swap(scCounterListResponse* other);

  // implements Message ----------------------------------------------

  scCounterListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scCounterListResponse& from);
  void MergeFrom(const scCounterListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isMachine = 1;
  inline bool has_ismachine() const;
  inline void clear_ismachine();
  static const int kIsMachineFieldNumber = 1;
  inline bool ismachine() const;
  inline void set_ismachine(bool value);

  // repeated string counterName = 2;
  inline int countername_size() const;
  inline void clear_countername();
  static const int kCounterNameFieldNumber = 2;
  inline const ::std::string& countername(int index) const;
  inline ::std::string* mutable_countername(int index);
  inline void set_countername(int index, const ::std::string& value);
  inline void set_countername(int index, const char* value);
  inline void set_countername(int index, const char* value, size_t size);
  inline ::std::string* add_countername();
  inline void add_countername(const ::std::string& value);
  inline void add_countername(const char* value);
  inline void add_countername(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& countername() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_countername();

  // @@protoc_insertion_point(class_scope:agent.scCounterListResponse)
 private:
  inline void set_has_ismachine();
  inline void clear_has_ismachine();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> countername_;
  bool ismachine_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static scCounterListResponse* default_instance_;
};
// -------------------------------------------------------------------

class csAgentReady : public ::google::protobuf::Message {
 public:
  csAgentReady();
  virtual ~csAgentReady();

  csAgentReady(const csAgentReady& from);

  inline csAgentReady& operator=(const csAgentReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csAgentReady& default_instance();

  void Swap(csAgentReady* other);

  // implements Message ----------------------------------------------

  csAgentReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csAgentReady& from);
  void MergeFrom(const csAgentReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:agent.csAgentReady)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csAgentReady* default_instance_;
};
// -------------------------------------------------------------------

class CurrentProcess : public ::google::protobuf::Message {
 public:
  CurrentProcess();
  virtual ~CurrentProcess();

  CurrentProcess(const CurrentProcess& from);

  inline CurrentProcess& operator=(const CurrentProcess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentProcess& default_instance();

  void Swap(CurrentProcess* other);

  // implements Message ----------------------------------------------

  CurrentProcess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurrentProcess& from);
  void MergeFrom(const CurrentProcess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string processName = 1;
  inline bool has_processname() const;
  inline void clear_processname();
  static const int kProcessNameFieldNumber = 1;
  inline const ::std::string& processname() const;
  inline void set_processname(const ::std::string& value);
  inline void set_processname(const char* value);
  inline void set_processname(const char* value, size_t size);
  inline ::std::string* mutable_processname();
  inline ::std::string* release_processname();
  inline void set_allocated_processname(::std::string* processname);

  // repeated int32 processID = 2;
  inline int processid_size() const;
  inline void clear_processid();
  static const int kProcessIDFieldNumber = 2;
  inline ::google::protobuf::int32 processid(int index) const;
  inline void set_processid(int index, ::google::protobuf::int32 value);
  inline void add_processid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      processid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_processid();

  // @@protoc_insertion_point(class_scope:agent.CurrentProcess)
 private:
  inline void set_has_processname();
  inline void clear_has_processname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* processname_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > processid_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static CurrentProcess* default_instance_;
};
// -------------------------------------------------------------------

class csCurrentProcessListSend : public ::google::protobuf::Message {
 public:
  csCurrentProcessListSend();
  virtual ~csCurrentProcessListSend();

  csCurrentProcessListSend(const csCurrentProcessListSend& from);

  inline csCurrentProcessListSend& operator=(const csCurrentProcessListSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csCurrentProcessListSend& default_instance();

  void Swap(csCurrentProcessListSend* other);

  // implements Message ----------------------------------------------

  csCurrentProcessListSend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csCurrentProcessListSend& from);
  void MergeFrom(const csCurrentProcessListSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .agent.CurrentProcess processInfo = 1;
  inline int processinfo_size() const;
  inline void clear_processinfo();
  static const int kProcessInfoFieldNumber = 1;
  inline const ::agent::CurrentProcess& processinfo(int index) const;
  inline ::agent::CurrentProcess* mutable_processinfo(int index);
  inline ::agent::CurrentProcess* add_processinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::agent::CurrentProcess >&
      processinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::agent::CurrentProcess >*
      mutable_processinfo();

  // @@protoc_insertion_point(class_scope:agent.csCurrentProcessListSend)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::agent::CurrentProcess > processinfo_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csCurrentProcessListSend* default_instance_;
};
// -------------------------------------------------------------------

class scHealthCheck : public ::google::protobuf::Message {
 public:
  scHealthCheck();
  virtual ~scHealthCheck();

  scHealthCheck(const scHealthCheck& from);

  inline scHealthCheck& operator=(const scHealthCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scHealthCheck& default_instance();

  void Swap(scHealthCheck* other);

  // implements Message ----------------------------------------------

  scHealthCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scHealthCheck& from);
  void MergeFrom(const scHealthCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:agent.scHealthCheck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static scHealthCheck* default_instance_;
};
// -------------------------------------------------------------------

class csHealthAck : public ::google::protobuf::Message {
 public:
  csHealthAck();
  virtual ~csHealthAck();

  csHealthAck(const csHealthAck& from);

  inline csHealthAck& operator=(const csHealthAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csHealthAck& default_instance();

  void Swap(csHealthAck* other);

  // implements Message ----------------------------------------------

  csHealthAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csHealthAck& from);
  void MergeFrom(const csHealthAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:agent.csHealthAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csHealthAck* default_instance_;
};
// -------------------------------------------------------------------

class scProcessCommandRequest : public ::google::protobuf::Message {
 public:
  scProcessCommandRequest();
  virtual ~scProcessCommandRequest();

  scProcessCommandRequest(const scProcessCommandRequest& from);

  inline scProcessCommandRequest& operator=(const scProcessCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scProcessCommandRequest& default_instance();

  void Swap(scProcessCommandRequest* other);

  // implements Message ----------------------------------------------

  scProcessCommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scProcessCommandRequest& from);
  void MergeFrom(const scProcessCommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .agent.ProcessCommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::agent::ProcessCommandType type() const;
  inline void set_type(::agent::ProcessCommandType value);

  // required string processName = 2;
  inline bool has_processname() const;
  inline void clear_processname();
  static const int kProcessNameFieldNumber = 2;
  inline const ::std::string& processname() const;
  inline void set_processname(const ::std::string& value);
  inline void set_processname(const char* value);
  inline void set_processname(const char* value, size_t size);
  inline ::std::string* mutable_processname();
  inline ::std::string* release_processname();
  inline void set_allocated_processname(::std::string* processname);

  // @@protoc_insertion_point(class_scope:agent.scProcessCommandRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_processname();
  inline void clear_has_processname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* processname_;
  int type_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static scProcessCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class csProcessCommandResponse : public ::google::protobuf::Message {
 public:
  csProcessCommandResponse();
  virtual ~csProcessCommandResponse();

  csProcessCommandResponse(const csProcessCommandResponse& from);

  inline csProcessCommandResponse& operator=(const csProcessCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csProcessCommandResponse& default_instance();

  void Swap(csProcessCommandResponse* other);

  // implements Message ----------------------------------------------

  csProcessCommandResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csProcessCommandResponse& from);
  void MergeFrom(const csProcessCommandResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef csProcessCommandResponse_Result Result;
  static const Result SUCCESS = csProcessCommandResponse_Result_SUCCESS;
  static const Result FAILURE = csProcessCommandResponse_Result_FAILURE;
  static inline bool Result_IsValid(int value) {
    return csProcessCommandResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    csProcessCommandResponse_Result_Result_MIN;
  static const Result Result_MAX =
    csProcessCommandResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    csProcessCommandResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return csProcessCommandResponse_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return csProcessCommandResponse_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return csProcessCommandResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .agent.ProcessCommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::agent::ProcessCommandType type() const;
  inline void set_type(::agent::ProcessCommandType value);

  // repeated int32 processID = 2;
  inline int processid_size() const;
  inline void clear_processid();
  static const int kProcessIDFieldNumber = 2;
  inline ::google::protobuf::int32 processid(int index) const;
  inline void set_processid(int index, ::google::protobuf::int32 value);
  inline void add_processid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      processid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_processid();

  // required .agent.csProcessCommandResponse.Result result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::agent::csProcessCommandResponse_Result result() const;
  inline void set_result(::agent::csProcessCommandResponse_Result value);

  // optional string failReason = 4;
  inline bool has_failreason() const;
  inline void clear_failreason();
  static const int kFailReasonFieldNumber = 4;
  inline const ::std::string& failreason() const;
  inline void set_failreason(const ::std::string& value);
  inline void set_failreason(const char* value);
  inline void set_failreason(const char* value, size_t size);
  inline ::std::string* mutable_failreason();
  inline ::std::string* release_failreason();
  inline void set_allocated_failreason(::std::string* failreason);

  // @@protoc_insertion_point(class_scope:agent.csProcessCommandResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_failreason();
  inline void clear_has_failreason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > processid_;
  int type_;
  int result_;
  ::std::string* failreason_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csProcessCommandResponse* default_instance_;
};
// -------------------------------------------------------------------

class scCounterCommandRequest : public ::google::protobuf::Message {
 public:
  scCounterCommandRequest();
  virtual ~scCounterCommandRequest();

  scCounterCommandRequest(const scCounterCommandRequest& from);

  inline scCounterCommandRequest& operator=(const scCounterCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scCounterCommandRequest& default_instance();

  void Swap(scCounterCommandRequest* other);

  // implements Message ----------------------------------------------

  scCounterCommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scCounterCommandRequest& from);
  void MergeFrom(const scCounterCommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .agent.CounterCommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::agent::CounterCommandType type() const;
  inline void set_type(::agent::CounterCommandType value);

  // required string CounterName = 2;
  inline bool has_countername() const;
  inline void clear_countername();
  static const int kCounterNameFieldNumber = 2;
  inline const ::std::string& countername() const;
  inline void set_countername(const ::std::string& value);
  inline void set_countername(const char* value);
  inline void set_countername(const char* value, size_t size);
  inline ::std::string* mutable_countername();
  inline ::std::string* release_countername();
  inline void set_allocated_countername(::std::string* countername);

  // required bool isMachine = 3;
  inline bool has_ismachine() const;
  inline void clear_ismachine();
  static const int kIsMachineFieldNumber = 3;
  inline bool ismachine() const;
  inline void set_ismachine(bool value);

  // @@protoc_insertion_point(class_scope:agent.scCounterCommandRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_countername();
  inline void clear_has_countername();
  inline void set_has_ismachine();
  inline void clear_has_ismachine();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* countername_;
  int type_;
  bool ismachine_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static scCounterCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class csCounterCommandResponse : public ::google::protobuf::Message {
 public:
  csCounterCommandResponse();
  virtual ~csCounterCommandResponse();

  csCounterCommandResponse(const csCounterCommandResponse& from);

  inline csCounterCommandResponse& operator=(const csCounterCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csCounterCommandResponse& default_instance();

  void Swap(csCounterCommandResponse* other);

  // implements Message ----------------------------------------------

  csCounterCommandResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csCounterCommandResponse& from);
  void MergeFrom(const csCounterCommandResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef csCounterCommandResponse_Result Result;
  static const Result SUCCESS = csCounterCommandResponse_Result_SUCCESS;
  static const Result FAILURE = csCounterCommandResponse_Result_FAILURE;
  static inline bool Result_IsValid(int value) {
    return csCounterCommandResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    csCounterCommandResponse_Result_Result_MIN;
  static const Result Result_MAX =
    csCounterCommandResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    csCounterCommandResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return csCounterCommandResponse_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return csCounterCommandResponse_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return csCounterCommandResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .agent.CounterCommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::agent::CounterCommandType type() const;
  inline void set_type(::agent::CounterCommandType value);

  // required .agent.csCounterCommandResponse.Result result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::agent::csCounterCommandResponse_Result result() const;
  inline void set_result(::agent::csCounterCommandResponse_Result value);

  // optional string failReason = 4;
  inline bool has_failreason() const;
  inline void clear_failreason();
  static const int kFailReasonFieldNumber = 4;
  inline const ::std::string& failreason() const;
  inline void set_failreason(const ::std::string& value);
  inline void set_failreason(const char* value);
  inline void set_failreason(const char* value, size_t size);
  inline ::std::string* mutable_failreason();
  inline ::std::string* release_failreason();
  inline void set_allocated_failreason(::std::string* failreason);

  // @@protoc_insertion_point(class_scope:agent.csCounterCommandResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_failreason();
  inline void clear_has_failreason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  int result_;
  ::std::string* failreason_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csCounterCommandResponse* default_instance_;
};
// -------------------------------------------------------------------

class scStartRecord : public ::google::protobuf::Message {
 public:
  scStartRecord();
  virtual ~scStartRecord();

  scStartRecord(const scStartRecord& from);

  inline scStartRecord& operator=(const scStartRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scStartRecord& default_instance();

  void Swap(scStartRecord* other);

  // implements Message ----------------------------------------------

  scStartRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scStartRecord& from);
  void MergeFrom(const scStartRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isMachine = 5;
  inline bool has_ismachine() const;
  inline void clear_ismachine();
  static const int kIsMachineFieldNumber = 5;
  inline bool ismachine() const;
  inline void set_ismachine(bool value);

  // required int32 totalRecordTime = 1;
  inline bool has_totalrecordtime() const;
  inline void clear_totalrecordtime();
  static const int kTotalRecordTimeFieldNumber = 1;
  inline ::google::protobuf::int32 totalrecordtime() const;
  inline void set_totalrecordtime(::google::protobuf::int32 value);

  // required int32 interval = 2;
  inline bool has_interval() const;
  inline void clear_interval();
  static const int kIntervalFieldNumber = 2;
  inline ::google::protobuf::int32 interval() const;
  inline void set_interval(::google::protobuf::int32 value);

  // required int32 responseTime = 3;
  inline bool has_responsetime() const;
  inline void clear_responsetime();
  static const int kResponseTimeFieldNumber = 3;
  inline ::google::protobuf::int32 responsetime() const;
  inline void set_responsetime(::google::protobuf::int32 value);

  // optional int64 delay = 4;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 4;
  inline ::google::protobuf::int64 delay() const;
  inline void set_delay(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:agent.scStartRecord)
 private:
  inline void set_has_ismachine();
  inline void clear_has_ismachine();
  inline void set_has_totalrecordtime();
  inline void clear_has_totalrecordtime();
  inline void set_has_interval();
  inline void clear_has_interval();
  inline void set_has_responsetime();
  inline void clear_has_responsetime();
  inline void set_has_delay();
  inline void clear_has_delay();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool ismachine_;
  ::google::protobuf::int32 totalrecordtime_;
  ::google::protobuf::int32 interval_;
  ::google::protobuf::int32 responsetime_;
  ::google::protobuf::int64 delay_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static scStartRecord* default_instance_;
};
// -------------------------------------------------------------------

class scStopRecord : public ::google::protobuf::Message {
 public:
  scStopRecord();
  virtual ~scStopRecord();

  scStopRecord(const scStopRecord& from);

  inline scStopRecord& operator=(const scStopRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scStopRecord& default_instance();

  void Swap(scStopRecord* other);

  // implements Message ----------------------------------------------

  scStopRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scStopRecord& from);
  void MergeFrom(const scStopRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isMachine = 1;
  inline bool has_ismachine() const;
  inline void clear_ismachine();
  static const int kIsMachineFieldNumber = 1;
  inline bool ismachine() const;
  inline void set_ismachine(bool value);

  // @@protoc_insertion_point(class_scope:agent.scStopRecord)
 private:
  inline void set_has_ismachine();
  inline void clear_has_ismachine();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool ismachine_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static scStopRecord* default_instance_;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();

  void Swap(Log* other);

  // implements Message ----------------------------------------------

  Log* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timeStamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // required double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:agent.Log)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamp_;
  double value_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static Log* default_instance_;
};
// -------------------------------------------------------------------

class ProcessInfos : public ::google::protobuf::Message {
 public:
  ProcessInfos();
  virtual ~ProcessInfos();

  ProcessInfos(const ProcessInfos& from);

  inline ProcessInfos& operator=(const ProcessInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessInfos& default_instance();

  void Swap(ProcessInfos* other);

  // implements Message ----------------------------------------------

  ProcessInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcessInfos& from);
  void MergeFrom(const ProcessInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string counterName = 1;
  inline bool has_countername() const;
  inline void clear_countername();
  static const int kCounterNameFieldNumber = 1;
  inline const ::std::string& countername() const;
  inline void set_countername(const ::std::string& value);
  inline void set_countername(const char* value);
  inline void set_countername(const char* value, size_t size);
  inline ::std::string* mutable_countername();
  inline ::std::string* release_countername();
  inline void set_allocated_countername(::std::string* countername);

  // required string processName = 2;
  inline bool has_processname() const;
  inline void clear_processname();
  static const int kProcessNameFieldNumber = 2;
  inline const ::std::string& processname() const;
  inline void set_processname(const ::std::string& value);
  inline void set_processname(const char* value);
  inline void set_processname(const char* value, size_t size);
  inline ::std::string* mutable_processname();
  inline ::std::string* release_processname();
  inline void set_allocated_processname(::std::string* processname);

  // required int32 processID = 3;
  inline bool has_processid() const;
  inline void clear_processid();
  static const int kProcessIDFieldNumber = 3;
  inline ::google::protobuf::int32 processid() const;
  inline void set_processid(::google::protobuf::int32 value);

  // repeated .agent.Log logs = 4;
  inline int logs_size() const;
  inline void clear_logs();
  static const int kLogsFieldNumber = 4;
  inline const ::agent::Log& logs(int index) const;
  inline ::agent::Log* mutable_logs(int index);
  inline ::agent::Log* add_logs();
  inline const ::google::protobuf::RepeatedPtrField< ::agent::Log >&
      logs() const;
  inline ::google::protobuf::RepeatedPtrField< ::agent::Log >*
      mutable_logs();

  // @@protoc_insertion_point(class_scope:agent.ProcessInfos)
 private:
  inline void set_has_countername();
  inline void clear_has_countername();
  inline void set_has_processname();
  inline void clear_has_processname();
  inline void set_has_processid();
  inline void clear_has_processid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* countername_;
  ::std::string* processname_;
  ::google::protobuf::RepeatedPtrField< ::agent::Log > logs_;
  ::google::protobuf::int32 processid_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static ProcessInfos* default_instance_;
};
// -------------------------------------------------------------------

class csTotalProcessInfoSend : public ::google::protobuf::Message {
 public:
  csTotalProcessInfoSend();
  virtual ~csTotalProcessInfoSend();

  csTotalProcessInfoSend(const csTotalProcessInfoSend& from);

  inline csTotalProcessInfoSend& operator=(const csTotalProcessInfoSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csTotalProcessInfoSend& default_instance();

  void Swap(csTotalProcessInfoSend* other);

  // implements Message ----------------------------------------------

  csTotalProcessInfoSend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csTotalProcessInfoSend& from);
  void MergeFrom(const csTotalProcessInfoSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .agent.ProcessInfos info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::agent::ProcessInfos& info(int index) const;
  inline ::agent::ProcessInfos* mutable_info(int index);
  inline ::agent::ProcessInfos* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::agent::ProcessInfos >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::agent::ProcessInfos >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:agent.csTotalProcessInfoSend)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::agent::ProcessInfos > info_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csTotalProcessInfoSend* default_instance_;
};
// -------------------------------------------------------------------

class MachineInfos : public ::google::protobuf::Message {
 public:
  MachineInfos();
  virtual ~MachineInfos();

  MachineInfos(const MachineInfos& from);

  inline MachineInfos& operator=(const MachineInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineInfos& default_instance();

  void Swap(MachineInfos* other);

  // implements Message ----------------------------------------------

  MachineInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MachineInfos& from);
  void MergeFrom(const MachineInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string counterName = 1;
  inline bool has_countername() const;
  inline void clear_countername();
  static const int kCounterNameFieldNumber = 1;
  inline const ::std::string& countername() const;
  inline void set_countername(const ::std::string& value);
  inline void set_countername(const char* value);
  inline void set_countername(const char* value, size_t size);
  inline ::std::string* mutable_countername();
  inline ::std::string* release_countername();
  inline void set_allocated_countername(::std::string* countername);

  // repeated .agent.Log logs = 2;
  inline int logs_size() const;
  inline void clear_logs();
  static const int kLogsFieldNumber = 2;
  inline const ::agent::Log& logs(int index) const;
  inline ::agent::Log* mutable_logs(int index);
  inline ::agent::Log* add_logs();
  inline const ::google::protobuf::RepeatedPtrField< ::agent::Log >&
      logs() const;
  inline ::google::protobuf::RepeatedPtrField< ::agent::Log >*
      mutable_logs();

  // @@protoc_insertion_point(class_scope:agent.MachineInfos)
 private:
  inline void set_has_countername();
  inline void clear_has_countername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* countername_;
  ::google::protobuf::RepeatedPtrField< ::agent::Log > logs_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static MachineInfos* default_instance_;
};
// -------------------------------------------------------------------

class csTotalMachineInfoSend : public ::google::protobuf::Message {
 public:
  csTotalMachineInfoSend();
  virtual ~csTotalMachineInfoSend();

  csTotalMachineInfoSend(const csTotalMachineInfoSend& from);

  inline csTotalMachineInfoSend& operator=(const csTotalMachineInfoSend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csTotalMachineInfoSend& default_instance();

  void Swap(csTotalMachineInfoSend* other);

  // implements Message ----------------------------------------------

  csTotalMachineInfoSend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csTotalMachineInfoSend& from);
  void MergeFrom(const csTotalMachineInfoSend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .agent.MachineInfos info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::agent::MachineInfos& info(int index) const;
  inline ::agent::MachineInfos* mutable_info(int index);
  inline ::agent::MachineInfos* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::agent::MachineInfos >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::agent::MachineInfos >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:agent.csTotalMachineInfoSend)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::agent::MachineInfos > info_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csTotalMachineInfoSend* default_instance_;
};
// -------------------------------------------------------------------

class scProcessRestrictionRequest : public ::google::protobuf::Message {
 public:
  scProcessRestrictionRequest();
  virtual ~scProcessRestrictionRequest();

  scProcessRestrictionRequest(const scProcessRestrictionRequest& from);

  inline scProcessRestrictionRequest& operator=(const scProcessRestrictionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const scProcessRestrictionRequest& default_instance();

  void Swap(scProcessRestrictionRequest* other);

  // implements Message ----------------------------------------------

  scProcessRestrictionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const scProcessRestrictionRequest& from);
  void MergeFrom(const scProcessRestrictionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 processID = 1;
  inline bool has_processid() const;
  inline void clear_processid();
  static const int kProcessIDFieldNumber = 1;
  inline ::google::protobuf::int32 processid() const;
  inline void set_processid(::google::protobuf::int32 value);

  // required .agent.Restriction type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::agent::Restriction type() const;
  inline void set_type(::agent::Restriction value);

  // required int32 value1 = 3;
  inline bool has_value1() const;
  inline void clear_value1();
  static const int kValue1FieldNumber = 3;
  inline ::google::protobuf::int32 value1() const;
  inline void set_value1(::google::protobuf::int32 value);

  // optional int32 value2 = 4;
  inline bool has_value2() const;
  inline void clear_value2();
  static const int kValue2FieldNumber = 4;
  inline ::google::protobuf::int32 value2() const;
  inline void set_value2(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:agent.scProcessRestrictionRequest)
 private:
  inline void set_has_processid();
  inline void clear_has_processid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value1();
  inline void clear_has_value1();
  inline void set_has_value2();
  inline void clear_has_value2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 processid_;
  int type_;
  ::google::protobuf::int32 value1_;
  ::google::protobuf::int32 value2_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static scProcessRestrictionRequest* default_instance_;
};
// -------------------------------------------------------------------

class csProcessRestrictionResponse : public ::google::protobuf::Message {
 public:
  csProcessRestrictionResponse();
  virtual ~csProcessRestrictionResponse();

  csProcessRestrictionResponse(const csProcessRestrictionResponse& from);

  inline csProcessRestrictionResponse& operator=(const csProcessRestrictionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csProcessRestrictionResponse& default_instance();

  void Swap(csProcessRestrictionResponse* other);

  // implements Message ----------------------------------------------

  csProcessRestrictionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csProcessRestrictionResponse& from);
  void MergeFrom(const csProcessRestrictionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef csProcessRestrictionResponse_Result Result;
  static const Result SUCCESS = csProcessRestrictionResponse_Result_SUCCESS;
  static const Result FAILURE = csProcessRestrictionResponse_Result_FAILURE;
  static inline bool Result_IsValid(int value) {
    return csProcessRestrictionResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    csProcessRestrictionResponse_Result_Result_MIN;
  static const Result Result_MAX =
    csProcessRestrictionResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    csProcessRestrictionResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return csProcessRestrictionResponse_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return csProcessRestrictionResponse_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return csProcessRestrictionResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 processID = 1;
  inline bool has_processid() const;
  inline void clear_processid();
  static const int kProcessIDFieldNumber = 1;
  inline ::google::protobuf::int32 processid() const;
  inline void set_processid(::google::protobuf::int32 value);

  // required .agent.Restriction type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::agent::Restriction type() const;
  inline void set_type(::agent::Restriction value);

  // required .agent.csProcessRestrictionResponse.Result result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::agent::csProcessRestrictionResponse_Result result() const;
  inline void set_result(::agent::csProcessRestrictionResponse_Result value);

  // optional string failReason = 4;
  inline bool has_failreason() const;
  inline void clear_failreason();
  static const int kFailReasonFieldNumber = 4;
  inline const ::std::string& failreason() const;
  inline void set_failreason(const ::std::string& value);
  inline void set_failreason(const char* value);
  inline void set_failreason(const char* value, size_t size);
  inline ::std::string* mutable_failreason();
  inline ::std::string* release_failreason();
  inline void set_allocated_failreason(::std::string* failreason);

  // @@protoc_insertion_point(class_scope:agent.csProcessRestrictionResponse)
 private:
  inline void set_has_processid();
  inline void clear_has_processid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_failreason();
  inline void clear_has_failreason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 processid_;
  int type_;
  ::std::string* failreason_;
  int result_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csProcessRestrictionResponse* default_instance_;
};
// -------------------------------------------------------------------

class csRecordResponse : public ::google::protobuf::Message {
 public:
  csRecordResponse();
  virtual ~csRecordResponse();

  csRecordResponse(const csRecordResponse& from);

  inline csRecordResponse& operator=(const csRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const csRecordResponse& default_instance();

  void Swap(csRecordResponse* other);

  // implements Message ----------------------------------------------

  csRecordResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const csRecordResponse& from);
  void MergeFrom(const csRecordResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef csRecordResponse_Result Result;
  static const Result START_SUCCESS = csRecordResponse_Result_START_SUCCESS;
  static const Result START_FAILURE = csRecordResponse_Result_START_FAILURE;
  static const Result STOP_SUCCESS = csRecordResponse_Result_STOP_SUCCESS;
  static const Result STOP_FAILURE = csRecordResponse_Result_STOP_FAILURE;
  static inline bool Result_IsValid(int value) {
    return csRecordResponse_Result_IsValid(value);
  }
  static const Result Result_MIN =
    csRecordResponse_Result_Result_MIN;
  static const Result Result_MAX =
    csRecordResponse_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    csRecordResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return csRecordResponse_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return csRecordResponse_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return csRecordResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bool isMachine = 5;
  inline bool has_ismachine() const;
  inline void clear_ismachine();
  static const int kIsMachineFieldNumber = 5;
  inline bool ismachine() const;
  inline void set_ismachine(bool value);

  // required .agent.csRecordResponse.Result result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::agent::csRecordResponse_Result result() const;
  inline void set_result(::agent::csRecordResponse_Result value);

  // optional string failReason = 4;
  inline bool has_failreason() const;
  inline void clear_failreason();
  static const int kFailReasonFieldNumber = 4;
  inline const ::std::string& failreason() const;
  inline void set_failreason(const ::std::string& value);
  inline void set_failreason(const char* value);
  inline void set_failreason(const char* value, size_t size);
  inline ::std::string* mutable_failreason();
  inline ::std::string* release_failreason();
  inline void set_allocated_failreason(::std::string* failreason);

  // @@protoc_insertion_point(class_scope:agent.csRecordResponse)
 private:
  inline void set_has_ismachine();
  inline void clear_has_ismachine();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_failreason();
  inline void clear_has_failreason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool ismachine_;
  int result_;
  ::std::string* failreason_;
  friend void  protobuf_AddDesc_AgentProtocol_2eproto();
  friend void protobuf_AssignDesc_AgentProtocol_2eproto();
  friend void protobuf_ShutdownFile_AgentProtocol_2eproto();

  void InitAsDefaultInstance();
  static csRecordResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// csAgentIDRequest

// required int32 token = 1;
inline bool csAgentIDRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csAgentIDRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csAgentIDRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csAgentIDRequest::clear_token() {
  token_ = 0;
  clear_has_token();
}
inline ::google::protobuf::int32 csAgentIDRequest::token() const {
  // @@protoc_insertion_point(field_get:agent.csAgentIDRequest.token)
  return token_;
}
inline void csAgentIDRequest::set_token(::google::protobuf::int32 value) {
  set_has_token();
  token_ = value;
  // @@protoc_insertion_point(field_set:agent.csAgentIDRequest.token)
}

// required int32 hostIP = 2;
inline bool csAgentIDRequest::has_hostip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void csAgentIDRequest::set_has_hostip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void csAgentIDRequest::clear_has_hostip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void csAgentIDRequest::clear_hostip() {
  hostip_ = 0;
  clear_has_hostip();
}
inline ::google::protobuf::int32 csAgentIDRequest::hostip() const {
  // @@protoc_insertion_point(field_get:agent.csAgentIDRequest.hostIP)
  return hostip_;
}
inline void csAgentIDRequest::set_hostip(::google::protobuf::int32 value) {
  set_has_hostip();
  hostip_ = value;
  // @@protoc_insertion_point(field_set:agent.csAgentIDRequest.hostIP)
}

// required double ramSize = 3;
inline bool csAgentIDRequest::has_ramsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void csAgentIDRequest::set_has_ramsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void csAgentIDRequest::clear_has_ramsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void csAgentIDRequest::clear_ramsize() {
  ramsize_ = 0;
  clear_has_ramsize();
}
inline double csAgentIDRequest::ramsize() const {
  // @@protoc_insertion_point(field_get:agent.csAgentIDRequest.ramSize)
  return ramsize_;
}
inline void csAgentIDRequest::set_ramsize(double value) {
  set_has_ramsize();
  ramsize_ = value;
  // @@protoc_insertion_point(field_set:agent.csAgentIDRequest.ramSize)
}

// -------------------------------------------------------------------

// scAgentIDResponse

// required int32 agentID = 1;
inline bool scAgentIDResponse::has_agentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scAgentIDResponse::set_has_agentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scAgentIDResponse::clear_has_agentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scAgentIDResponse::clear_agentid() {
  agentid_ = 0;
  clear_has_agentid();
}
inline ::google::protobuf::int32 scAgentIDResponse::agentid() const {
  // @@protoc_insertion_point(field_get:agent.scAgentIDResponse.agentID)
  return agentid_;
}
inline void scAgentIDResponse::set_agentid(::google::protobuf::int32 value) {
  set_has_agentid();
  agentid_ = value;
  // @@protoc_insertion_point(field_set:agent.scAgentIDResponse.agentID)
}

// required bool alreadyRunning = 2;
inline bool scAgentIDResponse::has_alreadyrunning() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void scAgentIDResponse::set_has_alreadyrunning() {
  _has_bits_[0] |= 0x00000002u;
}
inline void scAgentIDResponse::clear_has_alreadyrunning() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void scAgentIDResponse::clear_alreadyrunning() {
  alreadyrunning_ = false;
  clear_has_alreadyrunning();
}
inline bool scAgentIDResponse::alreadyrunning() const {
  // @@protoc_insertion_point(field_get:agent.scAgentIDResponse.alreadyRunning)
  return alreadyrunning_;
}
inline void scAgentIDResponse::set_alreadyrunning(bool value) {
  set_has_alreadyrunning();
  alreadyrunning_ = value;
  // @@protoc_insertion_point(field_set:agent.scAgentIDResponse.alreadyRunning)
}

// -------------------------------------------------------------------

// csProcessListRequest

// -------------------------------------------------------------------

// scProcessListResponse

// repeated string processName = 1;
inline int scProcessListResponse::processname_size() const {
  return processname_.size();
}
inline void scProcessListResponse::clear_processname() {
  processname_.Clear();
}
inline const ::std::string& scProcessListResponse::processname(int index) const {
  // @@protoc_insertion_point(field_get:agent.scProcessListResponse.processName)
  return processname_.Get(index);
}
inline ::std::string* scProcessListResponse::mutable_processname(int index) {
  // @@protoc_insertion_point(field_mutable:agent.scProcessListResponse.processName)
  return processname_.Mutable(index);
}
inline void scProcessListResponse::set_processname(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:agent.scProcessListResponse.processName)
  processname_.Mutable(index)->assign(value);
}
inline void scProcessListResponse::set_processname(int index, const char* value) {
  processname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.scProcessListResponse.processName)
}
inline void scProcessListResponse::set_processname(int index, const char* value, size_t size) {
  processname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.scProcessListResponse.processName)
}
inline ::std::string* scProcessListResponse::add_processname() {
  return processname_.Add();
}
inline void scProcessListResponse::add_processname(const ::std::string& value) {
  processname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:agent.scProcessListResponse.processName)
}
inline void scProcessListResponse::add_processname(const char* value) {
  processname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:agent.scProcessListResponse.processName)
}
inline void scProcessListResponse::add_processname(const char* value, size_t size) {
  processname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:agent.scProcessListResponse.processName)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
scProcessListResponse::processname() const {
  // @@protoc_insertion_point(field_list:agent.scProcessListResponse.processName)
  return processname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
scProcessListResponse::mutable_processname() {
  // @@protoc_insertion_point(field_mutable_list:agent.scProcessListResponse.processName)
  return &processname_;
}

// -------------------------------------------------------------------

// csCounterListRequest

// required bool isMachine = 1;
inline bool csCounterListRequest::has_ismachine() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csCounterListRequest::set_has_ismachine() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csCounterListRequest::clear_has_ismachine() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csCounterListRequest::clear_ismachine() {
  ismachine_ = false;
  clear_has_ismachine();
}
inline bool csCounterListRequest::ismachine() const {
  // @@protoc_insertion_point(field_get:agent.csCounterListRequest.isMachine)
  return ismachine_;
}
inline void csCounterListRequest::set_ismachine(bool value) {
  set_has_ismachine();
  ismachine_ = value;
  // @@protoc_insertion_point(field_set:agent.csCounterListRequest.isMachine)
}

// -------------------------------------------------------------------

// scCounterListResponse

// required bool isMachine = 1;
inline bool scCounterListResponse::has_ismachine() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scCounterListResponse::set_has_ismachine() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scCounterListResponse::clear_has_ismachine() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scCounterListResponse::clear_ismachine() {
  ismachine_ = false;
  clear_has_ismachine();
}
inline bool scCounterListResponse::ismachine() const {
  // @@protoc_insertion_point(field_get:agent.scCounterListResponse.isMachine)
  return ismachine_;
}
inline void scCounterListResponse::set_ismachine(bool value) {
  set_has_ismachine();
  ismachine_ = value;
  // @@protoc_insertion_point(field_set:agent.scCounterListResponse.isMachine)
}

// repeated string counterName = 2;
inline int scCounterListResponse::countername_size() const {
  return countername_.size();
}
inline void scCounterListResponse::clear_countername() {
  countername_.Clear();
}
inline const ::std::string& scCounterListResponse::countername(int index) const {
  // @@protoc_insertion_point(field_get:agent.scCounterListResponse.counterName)
  return countername_.Get(index);
}
inline ::std::string* scCounterListResponse::mutable_countername(int index) {
  // @@protoc_insertion_point(field_mutable:agent.scCounterListResponse.counterName)
  return countername_.Mutable(index);
}
inline void scCounterListResponse::set_countername(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:agent.scCounterListResponse.counterName)
  countername_.Mutable(index)->assign(value);
}
inline void scCounterListResponse::set_countername(int index, const char* value) {
  countername_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.scCounterListResponse.counterName)
}
inline void scCounterListResponse::set_countername(int index, const char* value, size_t size) {
  countername_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.scCounterListResponse.counterName)
}
inline ::std::string* scCounterListResponse::add_countername() {
  return countername_.Add();
}
inline void scCounterListResponse::add_countername(const ::std::string& value) {
  countername_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:agent.scCounterListResponse.counterName)
}
inline void scCounterListResponse::add_countername(const char* value) {
  countername_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:agent.scCounterListResponse.counterName)
}
inline void scCounterListResponse::add_countername(const char* value, size_t size) {
  countername_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:agent.scCounterListResponse.counterName)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
scCounterListResponse::countername() const {
  // @@protoc_insertion_point(field_list:agent.scCounterListResponse.counterName)
  return countername_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
scCounterListResponse::mutable_countername() {
  // @@protoc_insertion_point(field_mutable_list:agent.scCounterListResponse.counterName)
  return &countername_;
}

// -------------------------------------------------------------------

// csAgentReady

// -------------------------------------------------------------------

// CurrentProcess

// required string processName = 1;
inline bool CurrentProcess::has_processname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrentProcess::set_has_processname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrentProcess::clear_has_processname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrentProcess::clear_processname() {
  if (processname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_->clear();
  }
  clear_has_processname();
}
inline const ::std::string& CurrentProcess::processname() const {
  // @@protoc_insertion_point(field_get:agent.CurrentProcess.processName)
  return *processname_;
}
inline void CurrentProcess::set_processname(const ::std::string& value) {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  processname_->assign(value);
  // @@protoc_insertion_point(field_set:agent.CurrentProcess.processName)
}
inline void CurrentProcess::set_processname(const char* value) {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  processname_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.CurrentProcess.processName)
}
inline void CurrentProcess::set_processname(const char* value, size_t size) {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  processname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.CurrentProcess.processName)
}
inline ::std::string* CurrentProcess::mutable_processname() {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.CurrentProcess.processName)
  return processname_;
}
inline ::std::string* CurrentProcess::release_processname() {
  clear_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = processname_;
    processname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CurrentProcess::set_allocated_processname(::std::string* processname) {
  if (processname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete processname_;
  }
  if (processname) {
    set_has_processname();
    processname_ = processname;
  } else {
    clear_has_processname();
    processname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.CurrentProcess.processName)
}

// repeated int32 processID = 2;
inline int CurrentProcess::processid_size() const {
  return processid_.size();
}
inline void CurrentProcess::clear_processid() {
  processid_.Clear();
}
inline ::google::protobuf::int32 CurrentProcess::processid(int index) const {
  // @@protoc_insertion_point(field_get:agent.CurrentProcess.processID)
  return processid_.Get(index);
}
inline void CurrentProcess::set_processid(int index, ::google::protobuf::int32 value) {
  processid_.Set(index, value);
  // @@protoc_insertion_point(field_set:agent.CurrentProcess.processID)
}
inline void CurrentProcess::add_processid(::google::protobuf::int32 value) {
  processid_.Add(value);
  // @@protoc_insertion_point(field_add:agent.CurrentProcess.processID)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CurrentProcess::processid() const {
  // @@protoc_insertion_point(field_list:agent.CurrentProcess.processID)
  return processid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CurrentProcess::mutable_processid() {
  // @@protoc_insertion_point(field_mutable_list:agent.CurrentProcess.processID)
  return &processid_;
}

// -------------------------------------------------------------------

// csCurrentProcessListSend

// repeated .agent.CurrentProcess processInfo = 1;
inline int csCurrentProcessListSend::processinfo_size() const {
  return processinfo_.size();
}
inline void csCurrentProcessListSend::clear_processinfo() {
  processinfo_.Clear();
}
inline const ::agent::CurrentProcess& csCurrentProcessListSend::processinfo(int index) const {
  // @@protoc_insertion_point(field_get:agent.csCurrentProcessListSend.processInfo)
  return processinfo_.Get(index);
}
inline ::agent::CurrentProcess* csCurrentProcessListSend::mutable_processinfo(int index) {
  // @@protoc_insertion_point(field_mutable:agent.csCurrentProcessListSend.processInfo)
  return processinfo_.Mutable(index);
}
inline ::agent::CurrentProcess* csCurrentProcessListSend::add_processinfo() {
  // @@protoc_insertion_point(field_add:agent.csCurrentProcessListSend.processInfo)
  return processinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::agent::CurrentProcess >&
csCurrentProcessListSend::processinfo() const {
  // @@protoc_insertion_point(field_list:agent.csCurrentProcessListSend.processInfo)
  return processinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::agent::CurrentProcess >*
csCurrentProcessListSend::mutable_processinfo() {
  // @@protoc_insertion_point(field_mutable_list:agent.csCurrentProcessListSend.processInfo)
  return &processinfo_;
}

// -------------------------------------------------------------------

// scHealthCheck

// -------------------------------------------------------------------

// csHealthAck

// -------------------------------------------------------------------

// scProcessCommandRequest

// required .agent.ProcessCommandType type = 1;
inline bool scProcessCommandRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scProcessCommandRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scProcessCommandRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scProcessCommandRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::agent::ProcessCommandType scProcessCommandRequest::type() const {
  // @@protoc_insertion_point(field_get:agent.scProcessCommandRequest.type)
  return static_cast< ::agent::ProcessCommandType >(type_);
}
inline void scProcessCommandRequest::set_type(::agent::ProcessCommandType value) {
  assert(::agent::ProcessCommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:agent.scProcessCommandRequest.type)
}

// required string processName = 2;
inline bool scProcessCommandRequest::has_processname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void scProcessCommandRequest::set_has_processname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void scProcessCommandRequest::clear_has_processname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void scProcessCommandRequest::clear_processname() {
  if (processname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_->clear();
  }
  clear_has_processname();
}
inline const ::std::string& scProcessCommandRequest::processname() const {
  // @@protoc_insertion_point(field_get:agent.scProcessCommandRequest.processName)
  return *processname_;
}
inline void scProcessCommandRequest::set_processname(const ::std::string& value) {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  processname_->assign(value);
  // @@protoc_insertion_point(field_set:agent.scProcessCommandRequest.processName)
}
inline void scProcessCommandRequest::set_processname(const char* value) {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  processname_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.scProcessCommandRequest.processName)
}
inline void scProcessCommandRequest::set_processname(const char* value, size_t size) {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  processname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.scProcessCommandRequest.processName)
}
inline ::std::string* scProcessCommandRequest::mutable_processname() {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.scProcessCommandRequest.processName)
  return processname_;
}
inline ::std::string* scProcessCommandRequest::release_processname() {
  clear_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = processname_;
    processname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void scProcessCommandRequest::set_allocated_processname(::std::string* processname) {
  if (processname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete processname_;
  }
  if (processname) {
    set_has_processname();
    processname_ = processname;
  } else {
    clear_has_processname();
    processname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.scProcessCommandRequest.processName)
}

// -------------------------------------------------------------------

// csProcessCommandResponse

// required .agent.ProcessCommandType type = 1;
inline bool csProcessCommandResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csProcessCommandResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csProcessCommandResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csProcessCommandResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::agent::ProcessCommandType csProcessCommandResponse::type() const {
  // @@protoc_insertion_point(field_get:agent.csProcessCommandResponse.type)
  return static_cast< ::agent::ProcessCommandType >(type_);
}
inline void csProcessCommandResponse::set_type(::agent::ProcessCommandType value) {
  assert(::agent::ProcessCommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:agent.csProcessCommandResponse.type)
}

// repeated int32 processID = 2;
inline int csProcessCommandResponse::processid_size() const {
  return processid_.size();
}
inline void csProcessCommandResponse::clear_processid() {
  processid_.Clear();
}
inline ::google::protobuf::int32 csProcessCommandResponse::processid(int index) const {
  // @@protoc_insertion_point(field_get:agent.csProcessCommandResponse.processID)
  return processid_.Get(index);
}
inline void csProcessCommandResponse::set_processid(int index, ::google::protobuf::int32 value) {
  processid_.Set(index, value);
  // @@protoc_insertion_point(field_set:agent.csProcessCommandResponse.processID)
}
inline void csProcessCommandResponse::add_processid(::google::protobuf::int32 value) {
  processid_.Add(value);
  // @@protoc_insertion_point(field_add:agent.csProcessCommandResponse.processID)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
csProcessCommandResponse::processid() const {
  // @@protoc_insertion_point(field_list:agent.csProcessCommandResponse.processID)
  return processid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
csProcessCommandResponse::mutable_processid() {
  // @@protoc_insertion_point(field_mutable_list:agent.csProcessCommandResponse.processID)
  return &processid_;
}

// required .agent.csProcessCommandResponse.Result result = 3;
inline bool csProcessCommandResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void csProcessCommandResponse::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void csProcessCommandResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void csProcessCommandResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::agent::csProcessCommandResponse_Result csProcessCommandResponse::result() const {
  // @@protoc_insertion_point(field_get:agent.csProcessCommandResponse.result)
  return static_cast< ::agent::csProcessCommandResponse_Result >(result_);
}
inline void csProcessCommandResponse::set_result(::agent::csProcessCommandResponse_Result value) {
  assert(::agent::csProcessCommandResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:agent.csProcessCommandResponse.result)
}

// optional string failReason = 4;
inline bool csProcessCommandResponse::has_failreason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void csProcessCommandResponse::set_has_failreason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void csProcessCommandResponse::clear_has_failreason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void csProcessCommandResponse::clear_failreason() {
  if (failreason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_->clear();
  }
  clear_has_failreason();
}
inline const ::std::string& csProcessCommandResponse::failreason() const {
  // @@protoc_insertion_point(field_get:agent.csProcessCommandResponse.failReason)
  return *failreason_;
}
inline void csProcessCommandResponse::set_failreason(const ::std::string& value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
  // @@protoc_insertion_point(field_set:agent.csProcessCommandResponse.failReason)
}
inline void csProcessCommandResponse::set_failreason(const char* value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.csProcessCommandResponse.failReason)
}
inline void csProcessCommandResponse::set_failreason(const char* value, size_t size) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.csProcessCommandResponse.failReason)
}
inline ::std::string* csProcessCommandResponse::mutable_failreason() {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.csProcessCommandResponse.failReason)
  return failreason_;
}
inline ::std::string* csProcessCommandResponse::release_failreason() {
  clear_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failreason_;
    failreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void csProcessCommandResponse::set_allocated_failreason(::std::string* failreason) {
  if (failreason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failreason_;
  }
  if (failreason) {
    set_has_failreason();
    failreason_ = failreason;
  } else {
    clear_has_failreason();
    failreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.csProcessCommandResponse.failReason)
}

// -------------------------------------------------------------------

// scCounterCommandRequest

// required .agent.CounterCommandType type = 1;
inline bool scCounterCommandRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scCounterCommandRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scCounterCommandRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scCounterCommandRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::agent::CounterCommandType scCounterCommandRequest::type() const {
  // @@protoc_insertion_point(field_get:agent.scCounterCommandRequest.type)
  return static_cast< ::agent::CounterCommandType >(type_);
}
inline void scCounterCommandRequest::set_type(::agent::CounterCommandType value) {
  assert(::agent::CounterCommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:agent.scCounterCommandRequest.type)
}

// required string CounterName = 2;
inline bool scCounterCommandRequest::has_countername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void scCounterCommandRequest::set_has_countername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void scCounterCommandRequest::clear_has_countername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void scCounterCommandRequest::clear_countername() {
  if (countername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_->clear();
  }
  clear_has_countername();
}
inline const ::std::string& scCounterCommandRequest::countername() const {
  // @@protoc_insertion_point(field_get:agent.scCounterCommandRequest.CounterName)
  return *countername_;
}
inline void scCounterCommandRequest::set_countername(const ::std::string& value) {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  countername_->assign(value);
  // @@protoc_insertion_point(field_set:agent.scCounterCommandRequest.CounterName)
}
inline void scCounterCommandRequest::set_countername(const char* value) {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  countername_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.scCounterCommandRequest.CounterName)
}
inline void scCounterCommandRequest::set_countername(const char* value, size_t size) {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  countername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.scCounterCommandRequest.CounterName)
}
inline ::std::string* scCounterCommandRequest::mutable_countername() {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.scCounterCommandRequest.CounterName)
  return countername_;
}
inline ::std::string* scCounterCommandRequest::release_countername() {
  clear_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = countername_;
    countername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void scCounterCommandRequest::set_allocated_countername(::std::string* countername) {
  if (countername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete countername_;
  }
  if (countername) {
    set_has_countername();
    countername_ = countername;
  } else {
    clear_has_countername();
    countername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.scCounterCommandRequest.CounterName)
}

// required bool isMachine = 3;
inline bool scCounterCommandRequest::has_ismachine() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void scCounterCommandRequest::set_has_ismachine() {
  _has_bits_[0] |= 0x00000004u;
}
inline void scCounterCommandRequest::clear_has_ismachine() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void scCounterCommandRequest::clear_ismachine() {
  ismachine_ = false;
  clear_has_ismachine();
}
inline bool scCounterCommandRequest::ismachine() const {
  // @@protoc_insertion_point(field_get:agent.scCounterCommandRequest.isMachine)
  return ismachine_;
}
inline void scCounterCommandRequest::set_ismachine(bool value) {
  set_has_ismachine();
  ismachine_ = value;
  // @@protoc_insertion_point(field_set:agent.scCounterCommandRequest.isMachine)
}

// -------------------------------------------------------------------

// csCounterCommandResponse

// required .agent.CounterCommandType type = 1;
inline bool csCounterCommandResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csCounterCommandResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csCounterCommandResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csCounterCommandResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::agent::CounterCommandType csCounterCommandResponse::type() const {
  // @@protoc_insertion_point(field_get:agent.csCounterCommandResponse.type)
  return static_cast< ::agent::CounterCommandType >(type_);
}
inline void csCounterCommandResponse::set_type(::agent::CounterCommandType value) {
  assert(::agent::CounterCommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:agent.csCounterCommandResponse.type)
}

// required .agent.csCounterCommandResponse.Result result = 3;
inline bool csCounterCommandResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void csCounterCommandResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void csCounterCommandResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void csCounterCommandResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::agent::csCounterCommandResponse_Result csCounterCommandResponse::result() const {
  // @@protoc_insertion_point(field_get:agent.csCounterCommandResponse.result)
  return static_cast< ::agent::csCounterCommandResponse_Result >(result_);
}
inline void csCounterCommandResponse::set_result(::agent::csCounterCommandResponse_Result value) {
  assert(::agent::csCounterCommandResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:agent.csCounterCommandResponse.result)
}

// optional string failReason = 4;
inline bool csCounterCommandResponse::has_failreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void csCounterCommandResponse::set_has_failreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void csCounterCommandResponse::clear_has_failreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void csCounterCommandResponse::clear_failreason() {
  if (failreason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_->clear();
  }
  clear_has_failreason();
}
inline const ::std::string& csCounterCommandResponse::failreason() const {
  // @@protoc_insertion_point(field_get:agent.csCounterCommandResponse.failReason)
  return *failreason_;
}
inline void csCounterCommandResponse::set_failreason(const ::std::string& value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
  // @@protoc_insertion_point(field_set:agent.csCounterCommandResponse.failReason)
}
inline void csCounterCommandResponse::set_failreason(const char* value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.csCounterCommandResponse.failReason)
}
inline void csCounterCommandResponse::set_failreason(const char* value, size_t size) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.csCounterCommandResponse.failReason)
}
inline ::std::string* csCounterCommandResponse::mutable_failreason() {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.csCounterCommandResponse.failReason)
  return failreason_;
}
inline ::std::string* csCounterCommandResponse::release_failreason() {
  clear_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failreason_;
    failreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void csCounterCommandResponse::set_allocated_failreason(::std::string* failreason) {
  if (failreason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failreason_;
  }
  if (failreason) {
    set_has_failreason();
    failreason_ = failreason;
  } else {
    clear_has_failreason();
    failreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.csCounterCommandResponse.failReason)
}

// -------------------------------------------------------------------

// scStartRecord

// required bool isMachine = 5;
inline bool scStartRecord::has_ismachine() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scStartRecord::set_has_ismachine() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scStartRecord::clear_has_ismachine() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scStartRecord::clear_ismachine() {
  ismachine_ = false;
  clear_has_ismachine();
}
inline bool scStartRecord::ismachine() const {
  // @@protoc_insertion_point(field_get:agent.scStartRecord.isMachine)
  return ismachine_;
}
inline void scStartRecord::set_ismachine(bool value) {
  set_has_ismachine();
  ismachine_ = value;
  // @@protoc_insertion_point(field_set:agent.scStartRecord.isMachine)
}

// required int32 totalRecordTime = 1;
inline bool scStartRecord::has_totalrecordtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void scStartRecord::set_has_totalrecordtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void scStartRecord::clear_has_totalrecordtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void scStartRecord::clear_totalrecordtime() {
  totalrecordtime_ = 0;
  clear_has_totalrecordtime();
}
inline ::google::protobuf::int32 scStartRecord::totalrecordtime() const {
  // @@protoc_insertion_point(field_get:agent.scStartRecord.totalRecordTime)
  return totalrecordtime_;
}
inline void scStartRecord::set_totalrecordtime(::google::protobuf::int32 value) {
  set_has_totalrecordtime();
  totalrecordtime_ = value;
  // @@protoc_insertion_point(field_set:agent.scStartRecord.totalRecordTime)
}

// required int32 interval = 2;
inline bool scStartRecord::has_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void scStartRecord::set_has_interval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void scStartRecord::clear_has_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void scStartRecord::clear_interval() {
  interval_ = 0;
  clear_has_interval();
}
inline ::google::protobuf::int32 scStartRecord::interval() const {
  // @@protoc_insertion_point(field_get:agent.scStartRecord.interval)
  return interval_;
}
inline void scStartRecord::set_interval(::google::protobuf::int32 value) {
  set_has_interval();
  interval_ = value;
  // @@protoc_insertion_point(field_set:agent.scStartRecord.interval)
}

// required int32 responseTime = 3;
inline bool scStartRecord::has_responsetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void scStartRecord::set_has_responsetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void scStartRecord::clear_has_responsetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void scStartRecord::clear_responsetime() {
  responsetime_ = 0;
  clear_has_responsetime();
}
inline ::google::protobuf::int32 scStartRecord::responsetime() const {
  // @@protoc_insertion_point(field_get:agent.scStartRecord.responseTime)
  return responsetime_;
}
inline void scStartRecord::set_responsetime(::google::protobuf::int32 value) {
  set_has_responsetime();
  responsetime_ = value;
  // @@protoc_insertion_point(field_set:agent.scStartRecord.responseTime)
}

// optional int64 delay = 4;
inline bool scStartRecord::has_delay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void scStartRecord::set_has_delay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void scStartRecord::clear_has_delay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void scStartRecord::clear_delay() {
  delay_ = GOOGLE_LONGLONG(0);
  clear_has_delay();
}
inline ::google::protobuf::int64 scStartRecord::delay() const {
  // @@protoc_insertion_point(field_get:agent.scStartRecord.delay)
  return delay_;
}
inline void scStartRecord::set_delay(::google::protobuf::int64 value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:agent.scStartRecord.delay)
}

// -------------------------------------------------------------------

// scStopRecord

// required bool isMachine = 1;
inline bool scStopRecord::has_ismachine() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scStopRecord::set_has_ismachine() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scStopRecord::clear_has_ismachine() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scStopRecord::clear_ismachine() {
  ismachine_ = false;
  clear_has_ismachine();
}
inline bool scStopRecord::ismachine() const {
  // @@protoc_insertion_point(field_get:agent.scStopRecord.isMachine)
  return ismachine_;
}
inline void scStopRecord::set_ismachine(bool value) {
  set_has_ismachine();
  ismachine_ = value;
  // @@protoc_insertion_point(field_set:agent.scStopRecord.isMachine)
}

// -------------------------------------------------------------------

// Log

// required int64 timeStamp = 1;
inline bool Log::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Log::timestamp() const {
  // @@protoc_insertion_point(field_get:agent.Log.timeStamp)
  return timestamp_;
}
inline void Log::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:agent.Log.timeStamp)
}

// required double value = 2;
inline bool Log::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Log::value() const {
  // @@protoc_insertion_point(field_get:agent.Log.value)
  return value_;
}
inline void Log::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:agent.Log.value)
}

// -------------------------------------------------------------------

// ProcessInfos

// required string counterName = 1;
inline bool ProcessInfos::has_countername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessInfos::set_has_countername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessInfos::clear_has_countername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessInfos::clear_countername() {
  if (countername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_->clear();
  }
  clear_has_countername();
}
inline const ::std::string& ProcessInfos::countername() const {
  // @@protoc_insertion_point(field_get:agent.ProcessInfos.counterName)
  return *countername_;
}
inline void ProcessInfos::set_countername(const ::std::string& value) {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  countername_->assign(value);
  // @@protoc_insertion_point(field_set:agent.ProcessInfos.counterName)
}
inline void ProcessInfos::set_countername(const char* value) {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  countername_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.ProcessInfos.counterName)
}
inline void ProcessInfos::set_countername(const char* value, size_t size) {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  countername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.ProcessInfos.counterName)
}
inline ::std::string* ProcessInfos::mutable_countername() {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.ProcessInfos.counterName)
  return countername_;
}
inline ::std::string* ProcessInfos::release_countername() {
  clear_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = countername_;
    countername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProcessInfos::set_allocated_countername(::std::string* countername) {
  if (countername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete countername_;
  }
  if (countername) {
    set_has_countername();
    countername_ = countername;
  } else {
    clear_has_countername();
    countername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.ProcessInfos.counterName)
}

// required string processName = 2;
inline bool ProcessInfos::has_processname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessInfos::set_has_processname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessInfos::clear_has_processname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessInfos::clear_processname() {
  if (processname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_->clear();
  }
  clear_has_processname();
}
inline const ::std::string& ProcessInfos::processname() const {
  // @@protoc_insertion_point(field_get:agent.ProcessInfos.processName)
  return *processname_;
}
inline void ProcessInfos::set_processname(const ::std::string& value) {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  processname_->assign(value);
  // @@protoc_insertion_point(field_set:agent.ProcessInfos.processName)
}
inline void ProcessInfos::set_processname(const char* value) {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  processname_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.ProcessInfos.processName)
}
inline void ProcessInfos::set_processname(const char* value, size_t size) {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  processname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.ProcessInfos.processName)
}
inline ::std::string* ProcessInfos::mutable_processname() {
  set_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    processname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.ProcessInfos.processName)
  return processname_;
}
inline ::std::string* ProcessInfos::release_processname() {
  clear_has_processname();
  if (processname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = processname_;
    processname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProcessInfos::set_allocated_processname(::std::string* processname) {
  if (processname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete processname_;
  }
  if (processname) {
    set_has_processname();
    processname_ = processname;
  } else {
    clear_has_processname();
    processname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.ProcessInfos.processName)
}

// required int32 processID = 3;
inline bool ProcessInfos::has_processid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessInfos::set_has_processid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessInfos::clear_has_processid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessInfos::clear_processid() {
  processid_ = 0;
  clear_has_processid();
}
inline ::google::protobuf::int32 ProcessInfos::processid() const {
  // @@protoc_insertion_point(field_get:agent.ProcessInfos.processID)
  return processid_;
}
inline void ProcessInfos::set_processid(::google::protobuf::int32 value) {
  set_has_processid();
  processid_ = value;
  // @@protoc_insertion_point(field_set:agent.ProcessInfos.processID)
}

// repeated .agent.Log logs = 4;
inline int ProcessInfos::logs_size() const {
  return logs_.size();
}
inline void ProcessInfos::clear_logs() {
  logs_.Clear();
}
inline const ::agent::Log& ProcessInfos::logs(int index) const {
  // @@protoc_insertion_point(field_get:agent.ProcessInfos.logs)
  return logs_.Get(index);
}
inline ::agent::Log* ProcessInfos::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:agent.ProcessInfos.logs)
  return logs_.Mutable(index);
}
inline ::agent::Log* ProcessInfos::add_logs() {
  // @@protoc_insertion_point(field_add:agent.ProcessInfos.logs)
  return logs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::agent::Log >&
ProcessInfos::logs() const {
  // @@protoc_insertion_point(field_list:agent.ProcessInfos.logs)
  return logs_;
}
inline ::google::protobuf::RepeatedPtrField< ::agent::Log >*
ProcessInfos::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:agent.ProcessInfos.logs)
  return &logs_;
}

// -------------------------------------------------------------------

// csTotalProcessInfoSend

// repeated .agent.ProcessInfos info = 1;
inline int csTotalProcessInfoSend::info_size() const {
  return info_.size();
}
inline void csTotalProcessInfoSend::clear_info() {
  info_.Clear();
}
inline const ::agent::ProcessInfos& csTotalProcessInfoSend::info(int index) const {
  // @@protoc_insertion_point(field_get:agent.csTotalProcessInfoSend.info)
  return info_.Get(index);
}
inline ::agent::ProcessInfos* csTotalProcessInfoSend::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:agent.csTotalProcessInfoSend.info)
  return info_.Mutable(index);
}
inline ::agent::ProcessInfos* csTotalProcessInfoSend::add_info() {
  // @@protoc_insertion_point(field_add:agent.csTotalProcessInfoSend.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::agent::ProcessInfos >&
csTotalProcessInfoSend::info() const {
  // @@protoc_insertion_point(field_list:agent.csTotalProcessInfoSend.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::agent::ProcessInfos >*
csTotalProcessInfoSend::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:agent.csTotalProcessInfoSend.info)
  return &info_;
}

// -------------------------------------------------------------------

// MachineInfos

// required string counterName = 1;
inline bool MachineInfos::has_countername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MachineInfos::set_has_countername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MachineInfos::clear_has_countername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MachineInfos::clear_countername() {
  if (countername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_->clear();
  }
  clear_has_countername();
}
inline const ::std::string& MachineInfos::countername() const {
  // @@protoc_insertion_point(field_get:agent.MachineInfos.counterName)
  return *countername_;
}
inline void MachineInfos::set_countername(const ::std::string& value) {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  countername_->assign(value);
  // @@protoc_insertion_point(field_set:agent.MachineInfos.counterName)
}
inline void MachineInfos::set_countername(const char* value) {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  countername_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.MachineInfos.counterName)
}
inline void MachineInfos::set_countername(const char* value, size_t size) {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  countername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.MachineInfos.counterName)
}
inline ::std::string* MachineInfos::mutable_countername() {
  set_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    countername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.MachineInfos.counterName)
  return countername_;
}
inline ::std::string* MachineInfos::release_countername() {
  clear_has_countername();
  if (countername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = countername_;
    countername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MachineInfos::set_allocated_countername(::std::string* countername) {
  if (countername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete countername_;
  }
  if (countername) {
    set_has_countername();
    countername_ = countername;
  } else {
    clear_has_countername();
    countername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.MachineInfos.counterName)
}

// repeated .agent.Log logs = 2;
inline int MachineInfos::logs_size() const {
  return logs_.size();
}
inline void MachineInfos::clear_logs() {
  logs_.Clear();
}
inline const ::agent::Log& MachineInfos::logs(int index) const {
  // @@protoc_insertion_point(field_get:agent.MachineInfos.logs)
  return logs_.Get(index);
}
inline ::agent::Log* MachineInfos::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:agent.MachineInfos.logs)
  return logs_.Mutable(index);
}
inline ::agent::Log* MachineInfos::add_logs() {
  // @@protoc_insertion_point(field_add:agent.MachineInfos.logs)
  return logs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::agent::Log >&
MachineInfos::logs() const {
  // @@protoc_insertion_point(field_list:agent.MachineInfos.logs)
  return logs_;
}
inline ::google::protobuf::RepeatedPtrField< ::agent::Log >*
MachineInfos::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:agent.MachineInfos.logs)
  return &logs_;
}

// -------------------------------------------------------------------

// csTotalMachineInfoSend

// repeated .agent.MachineInfos info = 1;
inline int csTotalMachineInfoSend::info_size() const {
  return info_.size();
}
inline void csTotalMachineInfoSend::clear_info() {
  info_.Clear();
}
inline const ::agent::MachineInfos& csTotalMachineInfoSend::info(int index) const {
  // @@protoc_insertion_point(field_get:agent.csTotalMachineInfoSend.info)
  return info_.Get(index);
}
inline ::agent::MachineInfos* csTotalMachineInfoSend::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:agent.csTotalMachineInfoSend.info)
  return info_.Mutable(index);
}
inline ::agent::MachineInfos* csTotalMachineInfoSend::add_info() {
  // @@protoc_insertion_point(field_add:agent.csTotalMachineInfoSend.info)
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::agent::MachineInfos >&
csTotalMachineInfoSend::info() const {
  // @@protoc_insertion_point(field_list:agent.csTotalMachineInfoSend.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::agent::MachineInfos >*
csTotalMachineInfoSend::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:agent.csTotalMachineInfoSend.info)
  return &info_;
}

// -------------------------------------------------------------------

// scProcessRestrictionRequest

// required int32 processID = 1;
inline bool scProcessRestrictionRequest::has_processid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void scProcessRestrictionRequest::set_has_processid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void scProcessRestrictionRequest::clear_has_processid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void scProcessRestrictionRequest::clear_processid() {
  processid_ = 0;
  clear_has_processid();
}
inline ::google::protobuf::int32 scProcessRestrictionRequest::processid() const {
  // @@protoc_insertion_point(field_get:agent.scProcessRestrictionRequest.processID)
  return processid_;
}
inline void scProcessRestrictionRequest::set_processid(::google::protobuf::int32 value) {
  set_has_processid();
  processid_ = value;
  // @@protoc_insertion_point(field_set:agent.scProcessRestrictionRequest.processID)
}

// required .agent.Restriction type = 2;
inline bool scProcessRestrictionRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void scProcessRestrictionRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void scProcessRestrictionRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void scProcessRestrictionRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::agent::Restriction scProcessRestrictionRequest::type() const {
  // @@protoc_insertion_point(field_get:agent.scProcessRestrictionRequest.type)
  return static_cast< ::agent::Restriction >(type_);
}
inline void scProcessRestrictionRequest::set_type(::agent::Restriction value) {
  assert(::agent::Restriction_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:agent.scProcessRestrictionRequest.type)
}

// required int32 value1 = 3;
inline bool scProcessRestrictionRequest::has_value1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void scProcessRestrictionRequest::set_has_value1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void scProcessRestrictionRequest::clear_has_value1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void scProcessRestrictionRequest::clear_value1() {
  value1_ = 0;
  clear_has_value1();
}
inline ::google::protobuf::int32 scProcessRestrictionRequest::value1() const {
  // @@protoc_insertion_point(field_get:agent.scProcessRestrictionRequest.value1)
  return value1_;
}
inline void scProcessRestrictionRequest::set_value1(::google::protobuf::int32 value) {
  set_has_value1();
  value1_ = value;
  // @@protoc_insertion_point(field_set:agent.scProcessRestrictionRequest.value1)
}

// optional int32 value2 = 4;
inline bool scProcessRestrictionRequest::has_value2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void scProcessRestrictionRequest::set_has_value2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void scProcessRestrictionRequest::clear_has_value2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void scProcessRestrictionRequest::clear_value2() {
  value2_ = 0;
  clear_has_value2();
}
inline ::google::protobuf::int32 scProcessRestrictionRequest::value2() const {
  // @@protoc_insertion_point(field_get:agent.scProcessRestrictionRequest.value2)
  return value2_;
}
inline void scProcessRestrictionRequest::set_value2(::google::protobuf::int32 value) {
  set_has_value2();
  value2_ = value;
  // @@protoc_insertion_point(field_set:agent.scProcessRestrictionRequest.value2)
}

// -------------------------------------------------------------------

// csProcessRestrictionResponse

// required int32 processID = 1;
inline bool csProcessRestrictionResponse::has_processid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csProcessRestrictionResponse::set_has_processid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csProcessRestrictionResponse::clear_has_processid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csProcessRestrictionResponse::clear_processid() {
  processid_ = 0;
  clear_has_processid();
}
inline ::google::protobuf::int32 csProcessRestrictionResponse::processid() const {
  // @@protoc_insertion_point(field_get:agent.csProcessRestrictionResponse.processID)
  return processid_;
}
inline void csProcessRestrictionResponse::set_processid(::google::protobuf::int32 value) {
  set_has_processid();
  processid_ = value;
  // @@protoc_insertion_point(field_set:agent.csProcessRestrictionResponse.processID)
}

// required .agent.Restriction type = 2;
inline bool csProcessRestrictionResponse::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void csProcessRestrictionResponse::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void csProcessRestrictionResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void csProcessRestrictionResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::agent::Restriction csProcessRestrictionResponse::type() const {
  // @@protoc_insertion_point(field_get:agent.csProcessRestrictionResponse.type)
  return static_cast< ::agent::Restriction >(type_);
}
inline void csProcessRestrictionResponse::set_type(::agent::Restriction value) {
  assert(::agent::Restriction_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:agent.csProcessRestrictionResponse.type)
}

// required .agent.csProcessRestrictionResponse.Result result = 3;
inline bool csProcessRestrictionResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void csProcessRestrictionResponse::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void csProcessRestrictionResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void csProcessRestrictionResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::agent::csProcessRestrictionResponse_Result csProcessRestrictionResponse::result() const {
  // @@protoc_insertion_point(field_get:agent.csProcessRestrictionResponse.result)
  return static_cast< ::agent::csProcessRestrictionResponse_Result >(result_);
}
inline void csProcessRestrictionResponse::set_result(::agent::csProcessRestrictionResponse_Result value) {
  assert(::agent::csProcessRestrictionResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:agent.csProcessRestrictionResponse.result)
}

// optional string failReason = 4;
inline bool csProcessRestrictionResponse::has_failreason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void csProcessRestrictionResponse::set_has_failreason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void csProcessRestrictionResponse::clear_has_failreason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void csProcessRestrictionResponse::clear_failreason() {
  if (failreason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_->clear();
  }
  clear_has_failreason();
}
inline const ::std::string& csProcessRestrictionResponse::failreason() const {
  // @@protoc_insertion_point(field_get:agent.csProcessRestrictionResponse.failReason)
  return *failreason_;
}
inline void csProcessRestrictionResponse::set_failreason(const ::std::string& value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
  // @@protoc_insertion_point(field_set:agent.csProcessRestrictionResponse.failReason)
}
inline void csProcessRestrictionResponse::set_failreason(const char* value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.csProcessRestrictionResponse.failReason)
}
inline void csProcessRestrictionResponse::set_failreason(const char* value, size_t size) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.csProcessRestrictionResponse.failReason)
}
inline ::std::string* csProcessRestrictionResponse::mutable_failreason() {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.csProcessRestrictionResponse.failReason)
  return failreason_;
}
inline ::std::string* csProcessRestrictionResponse::release_failreason() {
  clear_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failreason_;
    failreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void csProcessRestrictionResponse::set_allocated_failreason(::std::string* failreason) {
  if (failreason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failreason_;
  }
  if (failreason) {
    set_has_failreason();
    failreason_ = failreason;
  } else {
    clear_has_failreason();
    failreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.csProcessRestrictionResponse.failReason)
}

// -------------------------------------------------------------------

// csRecordResponse

// required bool isMachine = 5;
inline bool csRecordResponse::has_ismachine() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void csRecordResponse::set_has_ismachine() {
  _has_bits_[0] |= 0x00000001u;
}
inline void csRecordResponse::clear_has_ismachine() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void csRecordResponse::clear_ismachine() {
  ismachine_ = false;
  clear_has_ismachine();
}
inline bool csRecordResponse::ismachine() const {
  // @@protoc_insertion_point(field_get:agent.csRecordResponse.isMachine)
  return ismachine_;
}
inline void csRecordResponse::set_ismachine(bool value) {
  set_has_ismachine();
  ismachine_ = value;
  // @@protoc_insertion_point(field_set:agent.csRecordResponse.isMachine)
}

// required .agent.csRecordResponse.Result result = 3;
inline bool csRecordResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void csRecordResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void csRecordResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void csRecordResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::agent::csRecordResponse_Result csRecordResponse::result() const {
  // @@protoc_insertion_point(field_get:agent.csRecordResponse.result)
  return static_cast< ::agent::csRecordResponse_Result >(result_);
}
inline void csRecordResponse::set_result(::agent::csRecordResponse_Result value) {
  assert(::agent::csRecordResponse_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:agent.csRecordResponse.result)
}

// optional string failReason = 4;
inline bool csRecordResponse::has_failreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void csRecordResponse::set_has_failreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void csRecordResponse::clear_has_failreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void csRecordResponse::clear_failreason() {
  if (failreason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_->clear();
  }
  clear_has_failreason();
}
inline const ::std::string& csRecordResponse::failreason() const {
  // @@protoc_insertion_point(field_get:agent.csRecordResponse.failReason)
  return *failreason_;
}
inline void csRecordResponse::set_failreason(const ::std::string& value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
  // @@protoc_insertion_point(field_set:agent.csRecordResponse.failReason)
}
inline void csRecordResponse::set_failreason(const char* value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
  // @@protoc_insertion_point(field_set_char:agent.csRecordResponse.failReason)
}
inline void csRecordResponse::set_failreason(const char* value, size_t size) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:agent.csRecordResponse.failReason)
}
inline ::std::string* csRecordResponse::mutable_failreason() {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    failreason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:agent.csRecordResponse.failReason)
  return failreason_;
}
inline ::std::string* csRecordResponse::release_failreason() {
  clear_has_failreason();
  if (failreason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = failreason_;
    failreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void csRecordResponse::set_allocated_failreason(::std::string* failreason) {
  if (failreason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete failreason_;
  }
  if (failreason) {
    set_has_failreason();
    failreason_ = failreason;
  } else {
    clear_has_failreason();
    failreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:agent.csRecordResponse.failReason)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace agent

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::agent::csProcessCommandResponse_Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::agent::csProcessCommandResponse_Result>() {
  return ::agent::csProcessCommandResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::agent::csCounterCommandResponse_Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::agent::csCounterCommandResponse_Result>() {
  return ::agent::csCounterCommandResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::agent::csProcessRestrictionResponse_Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::agent::csProcessRestrictionResponse_Result>() {
  return ::agent::csProcessRestrictionResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::agent::csRecordResponse_Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::agent::csRecordResponse_Result>() {
  return ::agent::csRecordResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::agent::agentType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::agent::agentType>() {
  return ::agent::agentType_descriptor();
}
template <> struct is_proto_enum< ::agent::ProcessCommandType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::agent::ProcessCommandType>() {
  return ::agent::ProcessCommandType_descriptor();
}
template <> struct is_proto_enum< ::agent::CounterCommandType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::agent::CounterCommandType>() {
  return ::agent::CounterCommandType_descriptor();
}
template <> struct is_proto_enum< ::agent::Restriction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::agent::Restriction>() {
  return ::agent::Restriction_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AgentProtocol_2eproto__INCLUDED
